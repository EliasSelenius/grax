

enum AnchorPoint { center; top_left; top_right; bottom_left; bottom_right; }

/* API:
    - unified coordinate system
    - draw:
        - text
        - rectangles
        - rectangle borders
        - lines
        - textures
    - layers
*/

RenderLayer* immediate_layer;
AnchorPoint anchor = .center;

// struct ImmediateRendererContex {
//     AnchorPoint anchor;
//     Color text_color;
//     Color rect_color;
// }

struct RenderLayer {
    Trianglebatch geometry;
    Trianglebatch text;
    OpenGLBlendingMode blend_mode;
}

struct Trianglebatch {
    vertex2D* vertices; // list
    uint32* indices; // list

    DrawBuffers db;
    Shader* shader;
    Texture2D texture;
}


// void layer_push() {}
// void layer_pop() {}

RenderLayer create_layer() {
    Trianglebatch create_trianglebatch() {
        Trianglebatch tb = {};
        tb.vertices = list_create(sizeof vertex2D);
        tb.indices  = list_create(sizeof uint32);
        tb.db = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);
        return tb;
    }

    RenderLayer layer = {};
    layer.text = create_trianglebatch();
    layer.geometry = create_trianglebatch();

    layer.text.shader = *ui_shader;
    layer.text.texture = CascadiaMono_texture;

    layer.geometry.shader = *ui_shader;
    layer.geometry.texture = white_texture;

    layer.blend_mode = .src_alpha;
    return layer;
}

void apply_camera(Transform2D t) {
    set_uniform("u_zoom", t.scale);
    set_uniform("u_cam_pos", t.pos.x, t.pos.y);
    set_uniform("u_cam_rot", t.rot);
}

void dispatch_layer(RenderLayer* layer, Transform2D cam) {
    void dispatch_trianglebatch(Trianglebatch* tb, Transform2D cam_tr) {
        let vert_count = list_length(tb.vertices);
        let ind_count = list_length(tb.indices);

        if vert_count != 0 and ind_count != 0 {
            update_buffers(*tb.db, tb.vertices, vert_count, tb.indices, ind_count);

            use(tb.shader);
            bind(tb.texture);
            apply_camera(cam_tr);
            draw_elements(tb.db);
        }

        list_clear(tb.vertices);
        list_clear(tb.indices);
    }

    disable_depth_test();

    set_blend_mode(layer.blend_mode);
    dispatch_trianglebatch(*layer.geometry, cam);
    enable_alpha_blending();
    dispatch_trianglebatch(*layer.text, cam);
}

void add_vertex(with Trianglebatch* tb, float32 x, y, u, v, Color color) {
    vertex2D vert = {};
    vert.pos = {x, y};
    vert.uv = {u, v};
    vert.color = color;
    list_add(*tb.vertices, *vert);
}

void add_triangle(with Trianglebatch* tb, uint32 i1, i2, i3) {
    let base = list_length(tb.vertices);
    i1 += base;
    i2 += base;
    i3 += base;
    list_add(*tb.indices, *i1);
    list_add(*tb.indices, *i2);
    list_add(*tb.indices, *i3);
}

void add_quad(with Trianglebatch* tb, vec2 pos, size, uv_offset, uv_scale, Color color) {

    add_triangle(tb, 0, 1, 2);
    add_triangle(tb, 1, 3, 2);

    float32 u  = uv_offset.x;
    float32 v  = uv_offset.y;
    float32 us = uv_offset.x + uv_scale.x;
    float32 vs = uv_offset.y + uv_scale.y;

    vec2 bl;
    vec2 br;
    vec2 tl;
    vec2 tr;

    switch anchor {
        case .center: {
            let sx = size.x * 0.5;
            let sy = size.y * 0.5;

            bl = { -sx, -sy };
            br = {  sx, -sy };
            tl = { -sx,  sy };
            tr = {  sx,  sy };
        } break;

        case .top_left: {
            bl = { 0, -size.y };
            br = { size.x, -size.y };
            tl = { 0, 0 };
            tr = { size.x, 0 };
        } break;

        case .top_right: {
            bl = { -size.x, -size.y };
            br = { 0, -size.y };
            tl = { -size.x, 0 };
            tr = { 0, 0 };
        } break;

        case .bottom_left: {
            bl = { 0, 0 };
            br = { size.x, 0 };
            tl = { 0,  size.y };
            tr = size;
        } break;

        case .bottom_right: {
            bl = { -size.x, 0 };
            br = { 0, 0 };
            tl = { -size.x, size.y };
            tr = { 0, size.y };
        } break;
    }

    add_vertex(tb,   pos.x+bl.x,  pos.y+bl.y,    u,  v,     color);
    add_vertex(tb,   pos.x+br.x,  pos.y+br.y,    us, v,     color);
    add_vertex(tb,   pos.x+tl.x,  pos.y+tl.y,    u,  vs,    color);
    add_vertex(tb,   pos.x+tr.x,  pos.y+tr.y,    us, vs,    color);

}






void draw_glyph(with RenderLayer* layer, vec2 pos, float32 size, char c, Color color) {
    uint32 index = c as uint8 - ' ';
    float32 col = index % 14;
    float32 row = index / 14 + 1;

    vec2 uv       = { col / 14.0,   1 - row / 7.0 };
    vec2 uv_scale = { 1.0 / 14.0,   1.0 / 7.0     };
    vec2 vsize    = { size * 0.5,   size          };
    add_quad(*layer.text, pos, vsize, uv, uv_scale, color);
}

vec2 draw_text(with RenderLayer* layer, vec2 pos, float32 size, string text, Color color) {
    float32 start = pos.x;
    for i : 0 .. text.length {
        char c = text.chars[i];

        if c == '\n' {
            pos.x = start;
            pos.y -= size;
            continue;
        }

        if c != ' ' draw_glyph(layer, pos, size, c, color);
        pos.x += size * 0.5;
    }

    return pos;
}

vec2 draw_text(with RenderLayer* layer, vec2 pos, float32 size, char* text, Color color) {
    float32 start = pos.x;

    while @text {
        switch @text {
            case '\n':
                pos.x = start;
                pos.y -= size;
                break;
            default:
                draw_glyph(layer, pos, size, @text, color);
            case ' ':
                pos.x += size * 0.5;
                break;
        }
        text++;
    }

    return pos;
}

// TODO: this is named oddly, its just right justifying it.
vec2 draw_text_backwards(with RenderLayer* layer, vec2 pos, float32 size, string text, Color color) {
    int32 i = text.length as int32 - 1;
    while i >= 0 {
        let c = text.chars[i--];

        if c != ' ' draw_glyph(layer, pos, size, c, color);
        pos.x -= size * 0.5;
    }

    return pos;
}



struct UI_Rect {
    vec2 center, size;
}

UI_Rect rect_pp(vec2 p1, p2) {
    UI_Rect rect = {};
    rect.center = (p1 + p2) / 2.0;
    vec2 t = p2 - p1;
    rect.size = {abs(t.x), abs(t.y)};
    return rect;
}

bool hover(UI_Rect r, vec2 pos) return point_inside_bb(pos, bottom_left(r), top_right(r));

vec2 point(UI_Rect rect, vec2 p) return point(rect, p.x, p.y);
vec2 point(UI_Rect rect, float32 x, y) return rect.center + rect.size*{x,y}*0.5;
vec2 bottom_left(UI_Rect r)  return point(r, -1, -1);
vec2 bottom_right(UI_Rect r) return point(r,  1, -1);
vec2 top_left(UI_Rect r)     return point(r, -1,  1);
vec2 top_right(UI_Rect r)    return point(r,  1,  1);

vec2 anchor_point(UI_Rect r, AnchorPoint ap) {
    vec2 a;
    switch ap {
        case .center:       a = { 0,  0}; break;
        case .top_left:     a = {-1,  1}; break;
        case .top_right:    a = { 1,  1}; break;
        case .bottom_left:  a = {-1, -1}; break;
        case .bottom_right: a = { 1, -1}; break;
    }

    return point(r, a);
}

vec2 center_text(UI_Rect r, float32 height, string str) {
    return r.center + make_vec((1.0 - str.length as float32) * height / 4.0, 0);
}

UI_Rect div_x(UI_Rect r, uint32 divisions, index) {
    float32 stride = r.size.x / divisions;
    UI_Rect res = {};
    res.size.y = r.size.y;
    res.size.x = stride;

    res.center.x = r.center.x + (-r.size.x + stride)/2.0 + stride*index;
    res.center.y = r.center.y;
    return res;
}

UI_Rect pad(UI_Rect r, float32 padding) return pad(r, make_vec2(padding));
UI_Rect pad(UI_Rect r, vec2 padding) {
    let res = r;
    res.size = res.size - padding;
    return res;
}

UI_Rect pad_top(UI_Rect r, float32 padding) {
    r.size.y -= padding;
    r.center.y -= padding/2.0;
    return r;
}

UI_Rect scale(UI_Rect rect, float32 x, y) {
    rect.size = rect.size * {x, y};
    return rect;
}

UI_Rect scale_pivot(UI_Rect rect, float32 x, y, px, py) {
    vec2 scale = {x, y};
    vec2 pivot = rect.center + {px, py} * rect.size*0.5;
    vec2 p1 = (rect.center - rect.size*0.5 - pivot) * scale + pivot;
    vec2 p2 = (rect.center + rect.size*0.5 - pivot) * scale + pivot;
    return rect_pp(p1, p2);
}

UI_Rect translate(UI_Rect rect, vec2 p) return translate(rect, p.x, p.y);
UI_Rect translate(UI_Rect rect, float32 x, y) {
    rect.center = rect.center + {x, y};
    return rect;
}

UI_Rect bottom_right(UI_Rect inner, outer) {
    // bottom_right(inner) = bottom_right(outer)
    // solve for inner.center and keep all else constant

    inner.center = outer.center + (outer.size - inner.size) * make_vec(1, -1) / 2.0;
    return inner;

    // return anchor_constraint(inner, AnchorPoint.bottom_right, bottom_right(outer));
}

UI_Rect anchor_place(UI_Rect rect, AnchorPoint ap, vec2 pos) {
    vec2 rel = pos - anchor_point(rect, ap);
    rect.center = rect.center + rel;
    return rect;
}

UI_Rect place(UI_Rect rect, float32 px, py, vec2 pos) {
    vec2 rel = pos - point(rect, px, py);
    rect.center = rect.center + rel;
    return rect;
}

UI_Rect grid(UI_Rect r, uint32 rows, cols, x, y) {
    vec2 size = {r.size.x/cols, r.size.y/rows};
    UI_Rect res = {};
    res.center = r.center + (size - r.size)/2.0 + size*make_vec(x, y);
    res.size = size;
    return res;
}

// coe - corner or edge
UI_Rect child(UI_Rect rect, float32 x, y, w, h) {
    vec2 p = rect.center + rect.size * {x,y} * 0.5;

    vec2 size = {w, h};
    vec2 pos = p - {x,y} * size * 0.5;

    return {pos, size};
}


void draw_rect(with RenderLayer* layer, vec2 pos, size, Color color) {
    add_quad(*layer.geometry, pos, size, vec2_zero, vec2_one, color);
}
void draw_rect(with RenderLayer* layer, UI_Rect rect, Color color) draw_rect(layer, rect.center, rect.size, color);
void draw_rect(UI_Rect r, Color color) { draw_rect(immediate_layer, r.center, r.size, color); }
void draw_rect(vec2 pos, size, Color color) { draw_rect(immediate_layer, pos, size, color); }

void draw_glyph(vec2 pos, float32 size, char c, Color color) { draw_glyph(immediate_layer, pos, size, c, color); }
vec2 draw_text(vec2 pos, float32 size, string txt, Color color) { return draw_text(immediate_layer, pos, size, txt, color); }
vec2 draw_text(vec2 pos, float32 size, char* txt, Color color)  { return draw_text(immediate_layer, pos, size, txt, color); }
vec2 draw_text_backwards(vec2 pos, float32 size, string text, Color color) { return draw_text_backwards(immediate_layer, pos, size, text, color); }

// enum TextWrap {
//     expand;
//     wrap_to_new_line;
//     // hidden; must implement scissor rendering for this feature to work
    
// }

// void draw_text(UI_Rect rect, float32 txt_height, string txt, Color txt_color, )
