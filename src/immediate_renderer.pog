

enum AnchorPoint { center; top_left; top_right; bottom_left; bottom_right; }

/* API:
    - unified coordinate system
    - draw:
        - text
        - rectangles
        - rectangle borders
        - lines
        - textures

*/

Trianglebatch immediate_text_batch;
Trianglebatch immediate_rect_batch;

struct Trianglebatch {
    vertex2D* vertices; // list
    uint32* indices; // list

    DrawBuffers draw_buffers;
    Shader shader;
    Texture2D texture;
}

Trianglebatch create_trianglebatch() {
    Trianglebatch tb = {};
    tb.vertices = list_create(sizeof vertex2D);
    tb.indices  = list_create(sizeof uint32);
    tb.draw_buffers = create_draw_buffers();
    return tb;
}

void dispatch_trianglebatch(Trianglebatch* tb) {
    let vert_count = list_length(tb.vertices);
    let ind_count = list_length(tb.indices);

    if vert_count != 0 and ind_count != 0 {
        update_buffers(*tb.draw_buffers, tb.vertices, vert_count, tb.indices, ind_count);

        use(*tb.shader);
        bind(tb.texture);

        enable_alpha_blending();
        disable_depth_test();

        draw_elements(tb.draw_buffers);
    }

    list_clear(tb.vertices);
    list_clear(tb.indices);
}

void init_immediate_renderer() {
    immediate_text_batch = create_trianglebatch();
    immediate_rect_batch = create_trianglebatch();

    immediate_text_batch.shader = ui_shader;
    immediate_rect_batch.shader = ui_shader;
    immediate_text_batch.texture = CascadiaMono_texture;
    immediate_rect_batch.texture = white_texture;
}

void dispatch_immediate() {
    dispatch_trianglebatch(*immediate_text_batch);
    dispatch_trianglebatch(*immediate_rect_batch);
}

void add_vertex(with Trianglebatch* tb, float32 x, y, u, v, Color color) {
    vertex2D vert = {};
    vert.pos = {x, y};
    vert.uv = {u, v};
    vert.color = color;
    list_add(*tb.vertices, *vert);
}

void add_triangle(with Trianglebatch* tb, uint32 i1, i2, i3) {
    let base = list_length(tb.vertices);
    i1 += base;
    i2 += base;
    i3 += base;
    list_add(*tb.indices, *i1);
    list_add(*tb.indices, *i2);
    list_add(*tb.indices, *i3);
}

void add_quad(with Trianglebatch* tb, vec2 pos, size, uv_offset, uv_scale, Color color) {
    let sx = size.x * 0.5;
    let sy = size.y * 0.5;

    add_triangle(tb, 0, 1, 2);
    add_triangle(tb, 1, 3, 2);

    float32 u  = uv_offset.x;
    float32 v  = uv_offset.y;
    float32 us = uv_offset.x + uv_scale.x;
    float32 vs = uv_offset.y + uv_scale.y;

    add_vertex(tb,   pos.x + -sx, pos.y + -sy,    u,  v,     color);
    add_vertex(tb,   pos.x +  sx, pos.y + -sy,    us, v,     color);
    add_vertex(tb,   pos.x + -sx, pos.y +  sy,    u,  vs,    color);
    add_vertex(tb,   pos.x +  sx, pos.y +  sy,    us, vs,    color);
}

void draw_rect(vec2 pos, size, Color color) {
    add_quad(*immediate_rect_batch, pos, size, vec2_zero, vec2_one, color);
}

void draw_image(Texture2D* image) {

}

void draw_char(vec2 pos, float32 size, char c, Color color) {
    uint32 index = c as uint8 - ' ';
    float32 col = index % 14;
    float32 row = index / 14 + 1;

    vec2 uv       = { col / 14.0,   1 - row / 7.0 };
    vec2 uv_scale = { 1.0 / 14.0,   1.0 / 7.0     };
    vec2 vsize    = { size * 0.5,   size          };
    add_quad(*immediate_text_batch, pos, vsize, uv, uv_scale, color);
}

vec2 draw_text(vec2 pos, float32 size, string text, Color color) {
    float32 start = pos.x;

    for i : 0 .. text.length {
        char c = text.chars[i];

        if c == '\n' {
            pos.x = start;
            pos.y -= size;
            continue;
        }

        if c != ' ' draw_char(pos, size, c, color);
        pos.x += size * 0.5;
    }

    return pos;
}

vec2 draw_text_backwards(vec2 pos, float32 size, string text, Color color) {
    int32 i = text.length as int32 - 1;
    while i >= 0 {
        let c = text.chars[i--];

        if c != ' ' draw_char(pos, size, c, color);
        pos.x -= size * 0.5;
    }

    return pos;
}

vec2 draw_text(vec2 pos, float32 size, char* text, Color color) {

    float32 start = pos.x;

    while @text {
        switch @text {
            case '\n':
                pos.x = start;
                pos.y -= size;
                break;
            default:
                draw_char(pos, size, @text, color);
            case ' ':
                pos.x += size * 0.5;
                break;
        }
        text++;
    }

    return pos;
}

