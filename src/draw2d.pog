
struct Draw2D_Instance_Data {
    vec3 pos;
    float32 rot;
    vec2 scale;
    float32 health;
    float32 padding0;
    vec2 uv_offset;
    vec2 uv_scale;
    vec4 color_factor;
    vec4 color_additive;
    vec4 color_outline;
}

struct Draw2D_Instanced_Draw_Call {
    Draw2D_Instance_Data[..] instances;
    uint32 tex;
    DrawBuffers db;
}

struct Draw2D_Batch {
    Draw2D_Instanced_Draw_Call[..] draw_calls;
}

RendererData draw2d_renderer = {};
struct RendererData {
    Draw2D_Batch batch;
    Draw2D_Batch batch_semi_transparent;

    DrawBuffers quad_db;
}

void init_draw2d() {
    draw2d_renderer.quad_db = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);
    {
        float32 p = 0.5;
        vertex2D[] verts = { {-p, -p, 0, 0, White},
                             { p, -p, 1, 0, White},
                             { p,  p, 1, 1, White},
                             {-p,  p, 0, 1, White} };

        uint32[] inds = { 0, 1, 2,
                          0, 2, 3 };

        update_buffers(*draw2d_renderer.quad_db, verts, inds);
    }
}


struct Spritesheet {
    Image_Boundingbox[..] regions;
    Texture2D texture;
}

struct Sprite {
    vec2 uv_offset;
    vec2 uv_scale;
    Texture2D* tex;
    bool is_semi_transparent;
}


Sprite get_sprite(with Spritesheet* sheet, uint32 index) {
    Sprite s = {};
    s.tex = *sheet.texture;

    let bb = sheet.regions[index];
    ivec2 size = get_boundingbox_size(bb);
    s.uv_scale.x = size.x / s.tex.width as float32;
    s.uv_scale.y = size.y / s.tex.height as float32;
    s.uv_offset.x = bb.min.x / s.tex.width as float32;
    s.uv_offset.y = bb.min.y / s.tex.height as float32;

    return s;
}

Sprite make_sprite(Texture2D* tex) {
    return { uv_offset = vec2_zero, uv_scale = vec2_one, tex = tex };
}

ivec2 get_sprite_pixel_size(Sprite s) {
    return make_ivec(s.uv_scale * make_vec(s.tex.width, s.tex.height));
}



void draw_sprite(Transform2D tr, float32 depth, Sprite sprite) {
    draw_sprite(tr, depth, sprite, vec4_one, vec4_zero, vec4_zero);
}

void draw_sprite(Transform2D tr, float32 depth, Sprite sprite, vec4 color_factor, color_additive, color_outline) {
    draw_texture(draw2d_renderer.quad_db, tr, depth, sprite.tex, sprite.is_semi_transparent, sprite.uv_offset, sprite.uv_scale, color_factor, color_additive, color_outline);
}

void draw_sprite(DrawBuffers db, Transform2D tr, float32 depth, Sprite sprite, vec4 color_factor, color_additive, color_outline) {
    draw_texture(db, tr, depth, sprite.tex, sprite.is_semi_transparent, sprite.uv_offset, sprite.uv_scale, color_factor, color_additive, color_outline);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D* tex, bool tex_is_semi_transparent, vec4 color_factor, color_additive) {
    draw_texture(draw2d_renderer.quad_db, tr, depth, tex, tex_is_semi_transparent, vec2_zero, vec2_one, color_factor, color_additive, vec4_zero);
}

// void draw_texture(Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color_factor, color_additive) {
//     draw_texture(draw2d_renderer.quad_db, tr, depth, tex, bb, color_factor, color_additive);
// }

// void draw_texture(DrawBuffers db, Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color_factor, color_additive) {
//     vec2 uv_offset = {};
//     vec2 uv_scale = {};
//     ivec2 size = get_boundingbox_size(bb);
//     uv_scale.x = size.x / tex.width as float32;
//     uv_scale.y = size.y / tex.height as float32;
//     uv_offset.x = bb.min.x / tex.width as float32;
//     uv_offset.y = bb.min.y / tex.height as float32;

//     draw_texture(db, tr, depth, tex, uv_offset, uv_scale, color_factor, color_additive);
// }

void draw_texture(
    DrawBuffers db,
    Transform2D tr,
    float32 depth,
    Texture2D* tex,
    bool tex_is_semi_transparent,
    vec2 uv_offset, uv_scale,
    vec4 color_factor, color_additive, color_outline)
{

    Draw2D_Instance_Data ins = {};
    ins.pos = make_vec(tr.pos, depth);
    ins.rot = tr.rot;
    ins.scale = uv_scale * make_vec(tex.width, tex.height) * tr.scale;
    ins.health = 1.0;
    ins.uv_offset = uv_offset;
    ins.uv_scale  = uv_scale;
    ins.color_factor = color_factor;
    ins.color_additive = color_additive;
    ins.color_outline = color_outline;

    Draw2D_Batch* batch = *draw2d_renderer.batch;
    if tex_is_semi_transparent
    or color_factor.w < 1.0
        batch = *draw2d_renderer.batch_semi_transparent;

    draw_texture(batch, db, tex.gl_handle, ins);
}

void draw_texture(
    Draw2D_Batch* batch,
    DrawBuffers db,
    uint32 tex,
    Draw2D_Instance_Data ins_data)
{

    if batch.draw_calls == null  batch.draw_calls = list_create(sizeof Draw2D_Instanced_Draw_Call);

    Draw2D_Instanced_Draw_Call* draw_call = null;

    for 0 .. list_length(batch.draw_calls) {
        let dc = *(batch.draw_calls)[it];
        if dc.tex == tex
        and dc.db.vao == db.vao {
            // TODO: we might want to do something more elegant here
            dc.db.elements_count = db.elements_count;
            draw_call = dc;
            break;
        }
    }

    if draw_call == null {
        Draw2D_Instanced_Draw_Call dc = {};
        dc.instances = list_create(sizeof Draw2D_Instance_Data);
        dc.tex = tex;
        dc.db = db;
        draw_call = list_add(*batch.draw_calls, *dc);
    }

    list_add(*draw_call.instances, *ins_data);
}

void dispatch_sprites(Draw2D_Batch* batch, Transform2D cam) {
    apply_camera(cam);

    for 0 .. list_length(batch.draw_calls) {
        let dc = *batch.draw_calls[it];

        uint32 instance_count = list_length(dc.instances);
        update_ssbo("Instances2D", dc.instances as void*, instance_count * sizeof Draw2D_Instance_Data);

        bind_texture2D(dc.tex, 0);
        draw_elements(dc.db, instance_count);
        list_clear(dc.instances);
    }
}


void dispatch_sprites(Transform2D cam) {

    use(*default2d_shader);
    enable_depth_test();

    glDepthMask(true);
    // glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    disable_blending();
    // enable_alpha_blending();
    dispatch_sprites(*draw2d_renderer.batch, cam);


    glDepthMask(false);
    enable_alpha_blending();
    // enable_additive_blending();

    // glEnable(GL_BLEND);
    // glBlendEquation(GL_FUNC_ADD);
    // glBlendFunc(GL_SRC_ALPHA, GL_ONE);

    {
        let batch = *draw2d_renderer.batch_semi_transparent;
        for 0 .. list_length(batch.draw_calls) {
            let dc = *batch.draw_calls[it];

            int32 comp(Draw2D_Instance_Data* a, b) {
                return sign(b.pos.z - a.pos.z) as int32;
            }

            qsort(dc.instances, list_length(dc.instances), sizeof Draw2D_Instance_Data, comp);
        }
    }


    dispatch_sprites(*draw2d_renderer.batch_semi_transparent, cam);
}

