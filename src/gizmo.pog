
struct GizmoPoint {
    vec3 pos;
    Color color;
    float32 size;
}

// TODO: make GizmoPoint[..]
GizmoPoint* gizmo_points_list;
Color gizmo_current_color = White;

uint32 gizmo_points_vbo;
uint32 gizmo_points_vao;

Shader gizmo_points_shader;

void gizmo_setup() {
    gizmo_points_list = list_create(sizeof GizmoPoint);

    { // vao/vbo
        glGenVertexArrays(1, *gizmo_points_vao);
        glBindVertexArray(gizmo_points_vao);

        glGenBuffers(1, *gizmo_points_vbo);
        glBindBuffer(GL_ARRAY_BUFFER, gizmo_points_vbo);

        GizmoPoint* gp = null;
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, false, sizeof GizmoPoint, *gp.pos);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 4, GL_UNSIGNED_BYTE, true, sizeof GizmoPoint, *gp.color);
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(2, 1, GL_FLOAT, false, sizeof GizmoPoint, *gp.size);

        glBindVertexArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }

    gizmo_points_shader = load_shader("../grax/shaders/gizmo_points3D.glsl");

    glEnable(GL_PROGRAM_POINT_SIZE);
}

void gizmo_dispatch() {
    uint32 len = list_length(gizmo_points_list);

    update_buffer(gizmo_points_vbo, len * sizeof GizmoPoint, gizmo_points_list);

    use(*gizmo_points_shader);

    glBindVertexArray(gizmo_points_vao);
    glDrawArrays(GL_POINTS, 0, len);
    glBindVertexArray(0);

    list_clear(gizmo_points_list);
}


void gizmo_point(vec3 pos) { gizmo_point(pos, gizmo_current_color); }
void gizmo_point(vec3 pos, float32 size) { gizmo_point(pos, gizmo_current_color, size); }
void gizmo_point(vec3 pos, Color color) { gizmo_point(pos, color, 0.1); }
void gizmo_point(vec3 pos, Color color, float32 size) {
    GizmoPoint gp = { pos = pos, color = color, size = size };
    list_add(*gizmo_points_list, *gp);
}

// TODO: implement
void gizmo_transform(Transform* tr) {

    // TODO: this code dont know about 'cam'
    let ray = camera_ray(cam, screen2ndc(mouse_x as float32, mouse_y as float32));

    mat4 m = to_matrix(@tr);
    vec3 xaxis = normalize(sub(add(tr.position, xyz(m.row1)), cam.transform.position));
    vec3 yaxis = normalize(sub(add(tr.position, xyz(m.row2)), cam.transform.position));
    vec3 zaxis = normalize(sub(add(tr.position, xyz(m.row3)), cam.transform.position));

    float32 size = 0.2;
    if dot(ray, xaxis) > 0.999  size *= 2;



    void draw_arrow(vec3 center, vec3 dir, Color color, float32 size) {
        for 1 .. 5 gizmo_point(add(center, mul(dir, it / 5.0)), color, 0.05);
        gizmo_point(add(center, dir), color, size);
    }

    gizmo_point(tr.position, White);
    draw_arrow(tr.position, xyz(m.row1), Red, size);
    draw_arrow(tr.position, xyz(m.row2), Green, 0.2);
    draw_arrow(tr.position, xyz(m.row3), Blue, 0.2);
}

void gizmo_transform(Transform2D* tr) {

}

void gizmo_sphere(vec3 center, float32 radius) {
    // NOTE: we are just using gizmo_golden_sphere() for now, we might want to draw this gizmo differently
    uint32 n = (4*Pi*radius*radius) as uint32;
    gizmo_golden_sphere(n, center, radius);
}


void gizmo_golden_sphere(uint32 n, vec3 center, float32 radius) {
    float32 golden_ratio = (1.0 + sqrtf(5)) / 2.0;
    for 0 .. n {
        float32 phi = acosf(1 - 2 * (it + 0.5) / (n as float32));
        float32 angle = Tau * it / golden_ratio;
        vec3 pos = { cosf(angle) * sinf(phi), sinf(angle) * sinf(phi), cosf(phi) };
        gizmo_point(add(mul(pos, radius), center), Cyan);
    }
}