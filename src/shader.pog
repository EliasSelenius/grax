

// struct Shader_Manager {}

enum Shaderstages {
    Vertex      = 0b000001;
    TessControl = 0b000010;
    TessEval    = 0b000100;
    Geometry    = 0b001000;
    Fragment    = 0b010000;
    Compute     = 0b100000;
}

Shader* active_shader;
UBO*[..] uniform_buffer_objects = list_create(sizeof UBO*);
SSBO*[..] shader_storage_buffer_objects = list_create(sizeof SSBO*);

struct UBO {
    string name;
    uint32 binding_point;
    uint32 buffer_id;
}

struct SSBO {
    string name;
    uint32 binding_point;
    uint32 buffer_id;
}

void update_ssbo(char* name, void* data, uint32 size) {
    let ssbo = get_ssbo(name);
    update_buffer(ssbo.buffer_id, size, data);
}

Named_Binding_Point*[..] ssbo_binding_points = list_create(sizeof Named_Binding_Point*);
Named_Binding_Point*[..]  ubo_binding_points = list_create(sizeof Named_Binding_Point*);

struct Named_Binding_Point {
    string name;
    uint32 binding_point;
    uint32 buffer_id;
}

struct Shader {
    string name;
    uint32 gl_handle;
    StringBuilder debug_log;

    Shader_Uniform[..] uniforms;
    Shader_Uniform_Block[..] ubos;
    Shader_Storage_Block[..] ssbos;

    // TODO: implement introspection: https://www.khronos.org/opengl/wiki/Program_Introspection#Interface_query
    // TODO: glValidateProgram might produce some insightfull info
}

void use(Shader* s) {
    active_shader = s;
    glUseProgram(s.gl_handle);
}

void dispatch_compute(uint32 x, y, z) {
    glDispatchCompute(x, y, z);
}

// glBindBufferBase(GL_SHADER_STORAGE_BUFFER, index, buffer)


/*
void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params);
programInterface:
    GL_UNIFORM
    GL_UNIFORM_BLOCK
    GL_ATOMIC_COUNTER_BUFFER
    GL_PROGRAM_INPUT
    GL_PROGRAM_OUTPUT

    GL_VERTEX_SUBROUTINE
    GL_TESS_CONTROL_SUBROUTINE
    GL_TESS_EVALUATION_SUBROUTINE
    GL_GEOMETRY_SUBROUTINE
    GL_FRAGMENT_SUBROUTINE
    GL_COMPUTE_SUBROUTINE

    GL_VERTEX_SUBROUTINE_UNIFORM
    GL_TESS_CONTROL_SUBROUTINE_UNIFORM
    GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
    GL_GEOMETRY_SUBROUTINE_UNIFORM
    GL_FRAGMENT_SUBROUTINE_UNIFORM
    GL_COMPUTE_SUBROUTINE_UNIFORM

    GL_TRANSFORM_FEEDBACK_VARYING
    GL_BUFFER_VARIABLE
    GL_SHADER_STORAGE_BLOCK
    GL_TRANSFORM_FEEDBACK_BUFFER

pname:
    GL_ACTIVE_RESOURCES
    GL_MAX_NAME_LENGTH
    GL_MAX_NUM_ACTIVE_VARIABLES
    GL_MAX_NUM_COMPATIBLE_SUBROUTINES

void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name);

void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const Glenum * props, GLsizei bufSize, GLsizei * length, GLint * params);
*/

/*
GL_NAME_LENGTH                            Any except GL_ATOMIC_COUNTER_BUFFER and GL_TRANSFORM_FEEDBACK_BUFFER
GL_TYPE                                   GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_TRANSFORM_FEEDBACK_VARYING, GL_BUFFER_VARIABLE
GL_ARRAY_SIZE                             GL_UNIFORM, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM, GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM, GL_TRANSFORM_FEEDBACK_VARYING
GL_OFFSET                                 GL_UNIFORM, GL_BUFFER_VARIABLE, GL_TRANSFORM_FEEDBACK_VARYING
GL_BLOCK_INDEX                            GL_UNIFORM, GL_BUFFER_VARIABLE
GL_ARRAY_STRIDE                           GL_UNIFORM, GL_BUFFER_VARIABLE
GL_MATRIX_STRIDE                          GL_UNIFORM, GL_BUFFER_VARIABLE
GL_IS_ROW_MAJOR                           GL_UNIFORM, GL_BUFFER_VARIABLE
GL_ATOMIC_COUNTER_BUFFER_INDEX            GL_UNIFORM
GL_BUFFER_BINDING                         GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER
GL_BUFFER_DATA_SIZE                       GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER
GL_NUM_ACTIVE_VARIABLES                   GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER
GL_ACTIVE_VARIABLES                       GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_TRANSFORM_FEEDBACK_BUFFER
GL_REFERENCED_BY_VERTEX_SHADER            GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_REFERENCED_BY_TESS_CONTROL_SHADER      GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_REFERENCED_BY_TESS_EVALUATION_SHADER   GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_REFERENCED_BY_GEOMETRY_SHADER          GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_REFERENCED_BY_FRAGMENT_SHADER          GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_REFERENCED_BY_COMPUTE_SHADER           GL_UNIFORM, GL_UNIFORM_BLOCK, GL_ATOMIC_COUNTER_SHADER, GL_BUFFER, GL_SHADER_STORAGE_BLOCK, GL_BUFFER_VARIABLE, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_NUM_COMPATIBLE_SUBROUTINES             GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM, GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM
GL_COMPATIBLE_SUBROUTINES                 GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM, GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM
GL_TOP_LEVEL_ARRAY_SIZE                   GL_BUFFER_VARIABLE
GL_TOP_LEVEL_ARRAY_STRIDE                 GL_BUFFER_VARIABLE
GL_LOCATION                               GL_UNIFORM, GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT, GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM, GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM
GL_LOCATION_INDEX                         GL_PROGRAM_OUTPUT
GL_IS_PER_PATCH                           GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_LOCATION_COMPONENT                     GL_PROGRAM_INPUT, GL_PROGRAM_OUTPUT
GL_TRANSFORM_FEEDBACK_BUFFER_INDEX        GL_TRANSFORM_FEEDBACK_VARYING
GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE       GL_TRANSFORM_FEEDBACK_BUFFER


GL_UNIFORM
    GL_NAME_LENGTH
    GL_TYPE
    GL_ARRAY_SIZE
    GL_OFFSET
    GL_BLOCK_INDEX
    GL_ARRAY_STRIDE
    GL_MATRIX_STRIDE
    GL_IS_ROW_MAJOR
    GL_ATOMIC_COUNTER_BUFFER_INDEX
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER
    GL_LOCATION

GL_UNIFORM_BLOCK
    GL_NAME_LENGTH
    GL_BUFFER_BINDING
    GL_BUFFER_DATA_SIZE
    GL_NUM_ACTIVE_VARIABLES
    GL_ACTIVE_VARIABLES
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER

GL_ATOMIC_COUNTER_BUFFER
    GL_BUFFER_BINDING
    GL_BUFFER_DATA_SIZE
    GL_NUM_ACTIVE_VARIABLES
    GL_ACTIVE_VARIABLES

GL_PROGRAM_INPUT
    GL_NAME_LENGTH
    GL_TYPE
    GL_ARRAY_SIZE
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER
    GL_LOCATION
    GL_IS_PER_PATCH
    GL_LOCATION_COMPONENT

GL_PROGRAM_OUTPUT
    GL_NAME_LENGTH
    GL_TYPE
    GL_ARRAY_SIZE
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER
    GL_LOCATION
    GL_LOCATION_INDEX
    GL_IS_PER_PATCH
    GL_LOCATION_COMPONENT



GL_VERTEX_SUBROUTINE
GL_TESS_CONTROL_SUBROUTINE
GL_TESS_EVALUATION_SUBROUTINE
GL_GEOMETRY_SUBROUTINE
GL_FRAGMENT_SUBROUTINE
GL_COMPUTE_SUBROUTINE

GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM, GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM, GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM
    GL_NAME_LENGTH
    GL_ARRAY_SIZE
    GL_NUM_COMPATIBLE_SUBROUTINES
    GL_COMPATIBLE_SUBROUTINES
    GL_LOCATION

GL_TRANSFORM_FEEDBACK_VARYING
    GL_NAME_LENGTH
    GL_TYPE
    GL_ARRAY_SIZE
    GL_OFFSET
    GL_TRANSFORM_FEEDBACK_BUFFER_INDEX

GL_BUFFER_VARIABLE
    GL_NAME_LENGTH
    GL_TYPE
    GL_ARRAY_SIZE
    GL_OFFSET
    GL_BLOCK_INDEX
    GL_ARRAY_STRIDE
    GL_MATRIX_STRIDE
    GL_IS_ROW_MAJOR
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER
    GL_TOP_LEVEL_ARRAY_SIZE
    GL_TOP_LEVEL_ARRAY_STRIDE

GL_SHADER_STORAGE_BLOCK
    GL_NAME_LENGTH
    GL_BUFFER_BINDING
    GL_BUFFER_DATA_SIZE
    GL_NUM_ACTIVE_VARIABLES
    GL_ACTIVE_VARIABLES
    GL_REFERENCED_BY_VERTEX_SHADER GL_REFERENCED_BY_TESS_CONTROL_SHADER GL_REFERENCED_BY_TESS_EVALUATION_SHADER GL_REFERENCED_BY_GEOMETRY_SHADER GL_REFERENCED_BY_FRAGMENT_SHADER GL_REFERENCED_BY_COMPUTE_SHADER

GL_TRANSFORM_FEEDBACK_BUFFER
    GL_BUFFER_BINDING
    GL_BUFFER_DATA_SIZE
    GL_NUM_ACTIVE_VARIABLES
    GL_ACTIVE_VARIABLES
    GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE

*/

void get_program_resource(uint32 program, interface, index, GLenum[] props, void* output) {
    glGetProgramResourceiv(program, interface, index, props.length, props.data, props.length, null, output);
}

int32 get_program_resource_prop(uint32 program, interface, index, GLenum prop) {
    int32 res = 0;
    glGetProgramResourceiv(program, interface, index, 1, *prop, 1, null, *res);
    return res;
}

Shader_Resource_Flags get_program_resource_usedby_flags(uint32 program, interface, index) {
    struct Data {
        int32 used_by_vertex;
        int32 used_by_tess_control;
        int32 used_by_tess_evaluation;
        int32 used_by_geometry;
        int32 used_by_fragment;
        int32 used_by_compute;
    }

    GLenum[] props = {
        GL_REFERENCED_BY_VERTEX_SHADER, GL_REFERENCED_BY_TESS_CONTROL_SHADER, GL_REFERENCED_BY_TESS_EVALUATION_SHADER,
        GL_REFERENCED_BY_GEOMETRY_SHADER, GL_REFERENCED_BY_FRAGMENT_SHADER, GL_REFERENCED_BY_COMPUTE_SHADER
    };

    Data data = {};
    get_program_resource(program, interface, index, props, *data);

    Shader_Resource_Flags flags = data.used_by_vertex           << 0
                                | data.used_by_tess_control     << 1
                                | data.used_by_tess_evaluation  << 2
                                | data.used_by_geometry         << 3
                                | data.used_by_fragment         << 4
                                | data.used_by_compute          << 5;
    return flags;
}

string alloc_and_get_name(uint32 program, interface, index, name_len) {
    string name = {chars=malloc(name_len)};
    glGetProgramResourceName(program, interface, index, name_len, *name.length, name.chars);
    return name;
}

enum Shader_Resource_Flags {
    used_by_vert      = 0b00000001;
    used_by_tess_ctrl = 0b00000010;
    used_by_tess_eval = 0b00000100;
    used_by_geom      = 0b00001000;
    used_by_frag      = 0b00010000;
    used_by_comp      = 0b00100000;
    is_row_major      = 0b01000000;
    is_per_patch      = 0b10000000;
}

struct Shader_Uniform {
    Shader_Resource_Flags flags;
    string name;
    GLenum ogl_type;
    int32 array_size;
    int32 offset;
    int32 block_index;
    int32 array_stride;
    int32 matrix_stride;
    int32 atomic_counter_buffer_index;
    int32 location;
}

struct Shader_Uniform_Block {
    Shader_Resource_Flags flags;
    string name;
    int32 buffer_binding;
    int32 buffer_data_size;
    int32[] active_variables;
}

struct Shader_Storage_Block {
    Shader_Resource_Flags flags;
    string name;
    int32 buffer_binding;
    int32 buffer_data_size;
    int32[] active_variables;
}

void introspect_shader_program(Shader* program) {
    {
        int32 num_res = 0;
        glGetProgramInterfaceiv(program.gl_handle, GL_UNIFORM, GL_ACTIVE_RESOURCES, *num_res);

        Shader_Uniform[..] uniforms = list_create(sizeof Shader_Uniform);

        for 0 .. num_res {

            GLenum[] props = { GL_NAME_LENGTH, GL_TYPE, GL_ARRAY_SIZE, GL_OFFSET, GL_BLOCK_INDEX, GL_ARRAY_STRIDE, GL_MATRIX_STRIDE, GL_IS_ROW_MAJOR, GL_ATOMIC_COUNTER_BUFFER_INDEX, GL_LOCATION };
            struct Data {
                int32 name_length;
                int32 _type;
                int32 array_size;
                int32 offset;
                int32 block_index;
                int32 array_stride;
                int32 matrix_stride;
                int32 is_row_major;
                int32 atomic_counter_buffer_index;
                int32 location;
            }

            Data data = {};
            get_program_resource(program.gl_handle, GL_UNIFORM, it, props, *data);

            Shader_Uniform* uni = list_append(*uniforms);
            uni.flags = get_program_resource_usedby_flags(program.gl_handle, GL_UNIFORM, it);
            uni.flags |= data.is_row_major ? .is_row_major : 0;

            uni.name = alloc_and_get_name(program.gl_handle, GL_UNIFORM, it, data.name_length);
            uni.ogl_type                    = data._type;
            uni.array_size                  = data.array_size;
            uni.offset                      = data.offset;
            uni.block_index                 = data.block_index;
            uni.array_stride                = data.array_stride;
            uni.matrix_stride               = data.matrix_stride;
            uni.atomic_counter_buffer_index = data.atomic_counter_buffer_index;
            uni.location                    = data.location;
        }

        program.uniforms = uniforms;
    }

    {
        int32 num_res = 0;
        glGetProgramInterfaceiv(program.gl_handle, GL_UNIFORM_BLOCK, GL_ACTIVE_RESOURCES, *num_res);

        Shader_Uniform_Block[..] ubos = list_create(sizeof Shader_Uniform_Block);
        for 0 .. num_res {

            GLenum[] props = { GL_NAME_LENGTH, GL_BUFFER_BINDING, GL_BUFFER_DATA_SIZE, GL_NUM_ACTIVE_VARIABLES };
            struct Data {
                int32 name_length;
                int32 buffer_binding;
                int32 buffer_data_size;
                int32 num_active_variables;
            }

            Data data = {};
            get_program_resource(program.gl_handle, GL_UNIFORM_BLOCK, it, props, *data);

            Shader_Uniform_Block* res = list_append(*ubos);
            res.flags = get_program_resource_usedby_flags(program.gl_handle, GL_UNIFORM_BLOCK, it);
            res.name = alloc_and_get_name(program.gl_handle, GL_UNIFORM_BLOCK, it, data.name_length);
            res.buffer_binding = data.buffer_binding;
            res.buffer_data_size = data.buffer_data_size;
            res.active_variables.length = data.num_active_variables;

            res.active_variables.data = malloc(res.active_variables.length * sizeof int32);
            get_program_resource(program.gl_handle, GL_UNIFORM_BLOCK, it, { GL_ACTIVE_VARIABLES } as GLenum[], res.active_variables.data);
        }

        program.ubos = ubos;
    }

    {
        int32 num_res = 0;
        glGetProgramInterfaceiv(program.gl_handle, GL_SHADER_STORAGE_BLOCK, GL_ACTIVE_RESOURCES, *num_res);

        Shader_Storage_Block[..] ssbos = list_create(sizeof Shader_Storage_Block);

        for 0 .. num_res {

            GLenum[] props =  { GL_NAME_LENGTH, GL_BUFFER_BINDING, GL_BUFFER_DATA_SIZE, GL_NUM_ACTIVE_VARIABLES };
            struct Data {
                int32 name_length;
                int32 buffer_binding;
                int32 buffer_data_size;
                int32 num_active_variables;
            }

            Data data = {};
            get_program_resource(program.gl_handle, GL_SHADER_STORAGE_BLOCK, it, props, *data);

            Shader_Storage_Block* res = list_append(*ssbos);
            res.flags = get_program_resource_usedby_flags(program.gl_handle, GL_SHADER_STORAGE_BLOCK, it);
            res.name = alloc_and_get_name(program.gl_handle, GL_SHADER_STORAGE_BLOCK, it, data.name_length);
            res.buffer_binding = data.buffer_binding;
            res.buffer_data_size = data.buffer_data_size;
            res.active_variables.length = data.num_active_variables;

            res.active_variables.data = malloc(res.active_variables.length * sizeof int32);
            get_program_resource(program.gl_handle, GL_SHADER_STORAGE_BLOCK, it, { GL_ACTIVE_VARIABLES } as GLenum[], res.active_variables.data);
        }

        program.ssbos = ssbos;
    }


    if false { // printing:
        for 0 .. list_length(program.uniforms) {
            let uni = program.uniforms[it];
            // print("layout(location=", uni.location, ") ", opengl_const_to_glsl_type_name(uni.ogl_type), " ", name, ";\n");
            print("uniform: ", uni, "\n");
        }

        print("Listing Uniform Blocks\n");
        for 0 .. list_length(program.ubos) {
            let res = program.ubos[it];
            print("    ", res.buffer_binding, " ", res.name, " flags=", res.flags, " size=", res.buffer_data_size, "B\n");
            for 0 .. res.active_variables.length {
                print("        ", res.active_variables[it], "\n");
            }
        }

        print("Listing Storage Blocks\n");
        for 0 .. list_length(program.ssbos) {
            let res = program.ssbos[it];
            print("    ", res.buffer_binding, " ", res.name, " flags=", res.flags, " size=", res.buffer_data_size, "B\n");
            for 0 .. res.active_variables.length {
                print("        ", res.active_variables[it], "\n");
            }
        }
    }
}

UBO* get_ubo(char* name) { return get_ubo(make_string(name)); }
UBO* get_ubo(string name) {

    uint32 len = list_length(uniform_buffer_objects as void*);
    for 0 .. len {
        UBO* ubo = uniform_buffer_objects[it];
        if string_equals(name, ubo.name) return ubo;
    }

    UBO* ubo = malloc(sizeof UBO);
    ubo.binding_point = len;
    ubo.name = alloc_string_copy(name);

    glGenBuffers(1, *ubo.buffer_id);
    glBindBufferBase(GL_UNIFORM_BUFFER, ubo.binding_point, ubo.buffer_id);

    list_add(*uniform_buffer_objects as void**, *ubo as void*);

    return uniform_buffer_objects[len];
}

SSBO* get_ssbo(char* name) return get_ssbo(make_string(name));
SSBO* get_ssbo(string name) {

    uint32 len = list_length(shader_storage_buffer_objects as void*);
    for 0 .. len {
        SSBO* ssbo = shader_storage_buffer_objects[it];
        if string_equals(name, ssbo.name) return ssbo;
    }

    SSBO* ssbo = malloc(sizeof SSBO);
    ssbo.binding_point = len;
    ssbo.name = alloc_string_copy(name);

    glGenBuffers(1, *ssbo.buffer_id);
    glBindBufferBase(GL_SHADER_STORAGE_BUFFER, ssbo.binding_point, ssbo.buffer_id);

    list_add(*shader_storage_buffer_objects as void**, *ssbo as void*);

    return shader_storage_buffer_objects[len];
}

Named_Binding_Point* get_named_binding_point(string name, GLenum target, Named_Binding_Point*[..]* list) {
    uint32 len = list_length(@list);
    for 0 .. len {
        let bp = (@list)[it];
        if string_equals(name, bp.name) return bp;
    }

    Named_Binding_Point* bp = malloc(sizeof Named_Binding_Point);
    bp.binding_point = len;
    bp.name = alloc_string_copy(name);

    glGenBuffers(1, *bp.buffer_id);
    glBindBufferBase(target, bp.binding_point, bp.buffer_id);

    list_add(list, *bp);

    return (@list)[len];
}

void bind_ubos(with Shader* s) {
    int32 num_ubos;
    int32 max_name_len;
    glGetProgramiv(s.gl_handle, GL_ACTIVE_UNIFORM_BLOCKS, *num_ubos);
    glGetProgramiv(s.gl_handle, GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, *max_name_len);

    char* ubo_name = malloc(max_name_len as uint64); // TODO: might want to do stack allocation for this

    for 0 .. num_ubos {
        int32 name_len;
        glGetActiveUniformBlockName(s.gl_handle, it, max_name_len, *name_len, ubo_name);
        // uint32 ubo_index = glGetUniformBlockIndex(s.gl_handle, ubo_name);
        uint32 ubo_index = it;
        UBO* ubo = get_ubo(make_string(ubo_name));
        glUniformBlockBinding(s.gl_handle, ubo_index, ubo.binding_point);
    }

    free(ubo_name);
}

void bind_ssbos(Shader* s) {
    for 0 .. list_length(s.ssbos) {
        let info = s.ssbos[it];
        let ssbo = get_ssbo(info.name);
        glShaderStorageBlockBinding(s.gl_handle, it, ssbo.binding_point);
    }
}

void process_glsl_source(StringBuilder* sb, char* filename) {
    char* src = fileread(filename);

    sb_append(sb, "#line 1\n");

    char* buffer = src;
    uint32 line_num = 1;
    while @buffer {
        let line = substr_until(buffer, '\n');

        if starts_with(line.chars, "#include \"") {
            char* fn = buffer + 10;
            let len = substr_until(fn, '"').length - 1;
            fn[len] = 0 as char;

            process_glsl_source(sb, fn);

            sb_append(sb, "\n#line ");
            sb_append(sb, to_string(line_num + 1));
            sb_append(sb, "\n");
        } else {
            sb_append(sb, line);
        }


        line_num++;
        buffer += line.length;
    }

    free(src);
}

Shader load_shader(char* filename) return load_shader(filename, false, false);
Shader load_shader(char* filename, bool tess, geom) {

    StringBuilder src = sb_create();
    process_glsl_source(*src, filename);

    char* get_shader_source(bool incl, char* def_IO, shader_type, src) {
        if !incl return null;
        let sb = temp_builder();
        // NOTE: layout(binding) requires "#version 420" or later
        // NOTE: ssbo requires "#version 430 core"
        char* glsl_version = "#version 430 core\n";
        sb_append(sb, glsl_version);
        sb_append(sb, "#define IO ");
        if def_IO sb_append(sb, def_IO);
        sb_append(sb, "\n");
        sb_append(sb, "#define ");
        sb_append(sb, shader_type);
        sb_append(sb, "\n");
        sb_append(sb, src);

        return sb.content;
    }

    let vs = get_shader_source(true, "out", "VertexShader", src.content);
    let tc = get_shader_source(tess, null,  "TessControl", src.content);
    let te = get_shader_source(tess, null,  "TessEval", src.content);
    let gs = get_shader_source(geom, null,  "GeometryShader", src.content);
    let fs = get_shader_source(true, "in",  "FragmentShader", src.content);

    // TODO: what is the ownership of filename?
    Shader s = create_shader(make_string(filename), vs, tc, te, gs, fs);

    sb_free(src);
    return s;
}

Shader load_shader(char* frag_filename, char* vert_filename) {
    char* frag_src = fileread(frag_filename);
    char* vert_src = fileread(vert_filename);

    let s = create_shader(make_string(""), frag_src, vert_src);

    free(frag_src);
    free(vert_src);

    return s;
}

Shader create_shader(string name, char* fragsrc, vertsrc) return create_shader(name, vertsrc, null, null, null, fragsrc);
Shader create_shader(string name, char* vs_src, tc_src, te_src, gs_src, fs_src) {

    char* append_info_log(StringBuilder* sb, int32 len) {
        sb_grow(sb, len as uint32);
        char* info_log = sb.content + sb.length;
        sb.length += len as uint32 - 1; // GL_INFO_LOG_LENGTH includes zero terminator
        return info_log;
    }

    uint32 make_shader(Shader* program, GLenum _type, char* code) {

        char* get_shader_type_string(GLenum shader_type) {
            switch shader_type {
                case GL_COMPUTE_SHADER:         return "compute";
                case GL_VERTEX_SHADER:          return "vertex";
                case GL_TESS_CONTROL_SHADER:    return "tess_control";
                case GL_TESS_EVALUATION_SHADER: return "tess_evaluation";
                case GL_GEOMETRY_SHADER:        return "geometry";
                case GL_FRAGMENT_SHADER:        return "fragment";
            }

            return null;
        }

        uint32 shader = glCreateShader(_type);
        glShaderSource(shader, 1, *code, null); // null assumes null-terminated string
        glCompileShader(shader); // NOTE: my stinky laptop needed this

        GLint success = 0;
        glGetShaderiv(shader, GL_COMPILE_STATUS, *success);
        if success == 0 {
            let sb = *program.debug_log;

            let shader_type = get_shader_type_string(_type);
            sb_append(sb, shader_type);
            sb_append(sb, " info log:\n");

            GLint info_log_len = 0;
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, *info_log_len);
            char* info_log = append_info_log(sb, info_log_len);
            glGetShaderInfoLog(shader, info_log_len, null, info_log);
            sb_append(sb, "\n\n");

            sb_append(sb, shader_type);
            sb_append(sb, " source code:\n");
            sb_append(sb, code);
            sb_append(sb, "\n///////////////////////////END_OF_CODE///////////////////////////\n\n\n\n");

            print("[INFO]: ShaderProgram ", program.gl_handle, " \"", program.name, "\" ", shader_type, " shader failed to compile. info log was generated.\n");
        }

        glAttachShader(program.gl_handle, shader);
        return shader;
    }

    void cleanup_shader(Shader program, uint32 shader) {
        glDetachShader(program.gl_handle, shader);
        glDeleteShader(shader);
    }

    Shader program = {};
    // TODO: maybe remove possible extension from name. like .glsl
    program.name = name; // TODO: we dont know the ownership of name
    program.gl_handle = glCreateProgram();
    program.debug_log = sb_create(); // TODO: is it really necessary to have debug_log be a field on Shader, just make it a local...
    sb_append(*program.debug_log, "\n\n");

    let fs = make_shader(*program, GL_FRAGMENT_SHADER, fs_src);
    let vs = make_shader(*program, GL_VERTEX_SHADER, vs_src);

    uint32 tc;
    uint32 te;
    uint32 gs;

    if tc_src and te_src {
        tc = make_shader(*program, GL_TESS_CONTROL_SHADER, tc_src);
        te = make_shader(*program, GL_TESS_EVALUATION_SHADER, te_src);
    }

    if gs_src {
        gs = make_shader(*program, GL_GEOMETRY_SHADER, gs_src);
    }

    glLinkProgram(program.gl_handle);

    cleanup_shader(program, fs);
    cleanup_shader(program, vs);
    if tc_src and te_src {
        cleanup_shader(program, tc);
        cleanup_shader(program, te);
    }
    if gs_src {
        cleanup_shader(program, gs);
    }


    int32 status;
    glGetProgramiv(program.gl_handle, GL_LINK_STATUS, *status);
    if status == 0 {
        let sb = *program.debug_log;
        sb_append(sb, "ShaderProgram \"");
        sb_append(sb, program.name);
        sb_append(sb, "\" info log:\n");

        int32 info_log_len;
        glGetProgramiv(program.gl_handle, GL_INFO_LOG_LENGTH, *info_log_len);
        char* log = append_info_log(sb, info_log_len);
        glGetProgramInfoLog(program.gl_handle, info_log_len, null, log);

        let log_file = concat("shader_debug_log_", trim(substr_until(substr_to_end(program.name, '/'), '.'), 1), ".txt");
        filewrite(log_file, program.debug_log.content);

        print("[INFO]: ShaderProgram ", program.gl_handle, " \"", program.name, "\" failed to link. info log was generated.\n");

        glDeleteProgram(program.gl_handle);
        program.gl_handle = 0;
        return program;
    }


    bind_ubos(*program);

    // print("\nuniforms: ", program.name, "\n");
    introspect_shader_program(*program);

    bind_ssbos(*program);

    print("[INFO]: ShaderProgram ", program.gl_handle, " \"", program.name, "\" was successfully created.\n");
    return program;
}

void delete_shader(Shader* shader) {
    glDeleteProgram(shader.gl_handle);
    sb_free(shader.debug_log);


    if shader.uniforms != null {

        for 0 .. list_length(shader.uniforms) free(shader.uniforms[it].name.chars);
        for 0 .. list_length(shader.ubos)     free(shader.ubos[it].name.chars);
        for 0 .. list_length(shader.ssbos)    free(shader.ssbos[it].name.chars);

        list_delete(shader.uniforms);
        list_delete(shader.ubos);
        list_delete(shader.ssbos);

        shader.uniforms = null;
        shader.ubos = null;
        shader.ssbos = null;
    }

}

void set_uniform(char* name, int32   x)          glUniform1i (glGetUniformLocation(active_shader.gl_handle, name), x);
void set_uniform(char* name, int32   x, y)       glUniform2i (glGetUniformLocation(active_shader.gl_handle, name), x, y);
void set_uniform(char* name, int32   x, y, z)    glUniform3i (glGetUniformLocation(active_shader.gl_handle, name), x, y, z);
void set_uniform(char* name, int32   x, y, z, w) glUniform4i (glGetUniformLocation(active_shader.gl_handle, name), x, y, z, w);
void set_uniform(char* name, uint32  x)          glUniform1ui(glGetUniformLocation(active_shader.gl_handle, name), x);
void set_uniform(char* name, uint32  x, y)       glUniform2ui(glGetUniformLocation(active_shader.gl_handle, name), x, y);
void set_uniform(char* name, uint32  x, y, z)    glUniform3ui(glGetUniformLocation(active_shader.gl_handle, name), x, y, z);
void set_uniform(char* name, uint32  x, y, z, w) glUniform4ui(glGetUniformLocation(active_shader.gl_handle, name), x, y, z, w);
void set_uniform(char* name, float32 x)          glUniform1f (glGetUniformLocation(active_shader.gl_handle, name), x);
void set_uniform(char* name, float32 x, y)       glUniform2f (glGetUniformLocation(active_shader.gl_handle, name), x, y);
void set_uniform(char* name, float32 x, y, z)    glUniform3f (glGetUniformLocation(active_shader.gl_handle, name), x, y, z);
void set_uniform(char* name, float32 x, y, z, w) glUniform4f (glGetUniformLocation(active_shader.gl_handle, name), x, y, z, w);
void set_uniform(char* name, float64 x)          glUniform1d (glGetUniformLocation(active_shader.gl_handle, name), x);
void set_uniform(char* name, float64 x, y)       glUniform2d (glGetUniformLocation(active_shader.gl_handle, name), x, y);
void set_uniform(char* name, float64 x, y, z)    glUniform3d (glGetUniformLocation(active_shader.gl_handle, name), x, y, z);
void set_uniform(char* name, float64 x, y, z, w) glUniform4d (glGetUniformLocation(active_shader.gl_handle, name), x, y, z, w);

void set_uniform(char* name, vec2 v)  set_uniform(name, v.x, v.y);
void set_uniform(char* name, vec3 v)  set_uniform(name, v.x, v.y, v.z);
void set_uniform(char* name, vec4 v)  set_uniform(name, v.x, v.y, v.z, v.w);
void set_uniform(char* name, ivec2 v) set_uniform(name, v.x, v.y);
void set_uniform(char* name, ivec3 v) set_uniform(name, v.x, v.y, v.z);
void set_uniform(char* name, ivec4 v) set_uniform(name, v.x, v.y, v.z, v.w);

// void set_uniform(char* name, int32 count, float64* value) glUniform1dv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, float32* value) glUniform1fv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, int32* value)   glUniform1iv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, uint32* value)  glUniform1uiv(glGetUniformLocation(active_shader.gl_handle, name), count, value);

// void set_uniform(char* name, int32 count, float64* value) glUniform2dv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, float32* value) glUniform2fv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, int32* value)   glUniform2iv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, uint32* value)  glUniform2uiv(glGetUniformLocation(active_shader.gl_handle, name), count, value);

// void set_uniform(char* name, int32 count, float64* value) glUniform3dv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, float32* value) glUniform3fv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, int32* value)   glUniform3iv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, uint32* value)  glUniform3uiv(glGetUniformLocation(active_shader.gl_handle, name), count, value);

// void set_uniform(char* name, int32 count, float64* value) glUniform4dv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, float32* value) glUniform4fv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, int32* value)   glUniform4iv (glGetUniformLocation(active_shader.gl_handle, name), count, value);
// void set_uniform(char* name, int32 count, uint32* value)  glUniform4uiv(glGetUniformLocation(active_shader.gl_handle, name), count, value);



// type proc_glUniform1d                 = void(GLint /*location*/, GLdouble /*x*/);
// type proc_glUniform1dv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniform1f                 = void(GLint /*location*/, GLfloat /*v0*/);
// type proc_glUniform1fv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniform1i                 = void(GLint /*location*/, GLint /*v0*/);
// type proc_glUniform1iv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glUniform1ui                = void(GLint /*location*/, GLuint /*v0*/);
// type proc_glUniform1uiv               = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glUniform2d                 = void(GLint /*location*/, GLdouble /*x*/, GLdouble /*y*/);
// type proc_glUniform2dv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniform2f                 = void(GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/);
// type proc_glUniform2fv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniform2i                 = void(GLint /*location*/, GLint /*v0*/, GLint /*v1*/);
// type proc_glUniform2iv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glUniform2ui                = void(GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/);
// type proc_glUniform2uiv               = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glUniform3d                 = void(GLint /*location*/, GLdouble /*x*/, GLdouble /*y*/, GLdouble /*z*/);
// type proc_glUniform3dv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniform3f                 = void(GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/, GLfloat /*v2*/);
// type proc_glUniform3fv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniform3i                 = void(GLint /*location*/, GLint /*v0*/, GLint /*v1*/, GLint /*v2*/);
// type proc_glUniform3iv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glUniform3ui                = void(GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/, GLuint /*v2*/);
// type proc_glUniform3uiv               = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glUniform4d                 = void(GLint /*location*/, GLdouble /*x*/, GLdouble /*y*/, GLdouble /*z*/, GLdouble /*w*/);
// type proc_glUniform4dv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniform4f                 = void(GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/, GLfloat /*v2*/, GLfloat /*v3*/);
// type proc_glUniform4fv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniform4i                 = void(GLint /*location*/, GLint /*v0*/, GLint /*v1*/, GLint /*v2*/, GLint /*v3*/);
// type proc_glUniform4iv                = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glUniform4ui                = void(GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/, GLuint /*v2*/, GLuint /*v3*/);
// type proc_glUniform4uiv               = void(GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glUniformMatrix2dv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix2fv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix2x3dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix2x3fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix2x4dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix2x4fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix3dv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix3fv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix3x2dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix3x2fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix3x4dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix3x4fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix4dv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix4fv          = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix4x2dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix4x2fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glUniformMatrix4x3dv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glUniformMatrix4x3fv        = void(GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);

// type proc_glProgramUniform1d          = void(GLuint /*program*/, GLint /*location*/, GLdouble /*v0*/);
// type proc_glProgramUniform1dv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniform1f          = void(GLuint /*program*/, GLint /*location*/, GLfloat /*v0*/);
// type proc_glProgramUniform1fv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniform1i          = void(GLuint /*program*/, GLint /*location*/, GLint /*v0*/);
// type proc_glProgramUniform1iv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glProgramUniform1ui         = void(GLuint /*program*/, GLint /*location*/, GLuint /*v0*/);
// type proc_glProgramUniform1uiv        = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glProgramUniform2d          = void(GLuint /*program*/, GLint /*location*/, GLdouble /*v0*/, GLdouble /*v1*/);
// type proc_glProgramUniform2dv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniform2f          = void(GLuint /*program*/, GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/);
// type proc_glProgramUniform2fv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniform2i          = void(GLuint /*program*/, GLint /*location*/, GLint /*v0*/, GLint /*v1*/);
// type proc_glProgramUniform2iv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glProgramUniform2ui         = void(GLuint /*program*/, GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/);
// type proc_glProgramUniform2uiv        = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glProgramUniform3d          = void(GLuint /*program*/, GLint /*location*/, GLdouble /*v0*/, GLdouble /*v1*/, GLdouble /*v2*/);
// type proc_glProgramUniform3dv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniform3f          = void(GLuint /*program*/, GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/, GLfloat /*v2*/);
// type proc_glProgramUniform3fv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniform3i          = void(GLuint /*program*/, GLint /*location*/, GLint /*v0*/, GLint /*v1*/, GLint /*v2*/);
// type proc_glProgramUniform3iv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glProgramUniform3ui         = void(GLuint /*program*/, GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/, GLuint /*v2*/);
// type proc_glProgramUniform3uiv        = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glProgramUniform4d          = void(GLuint /*program*/, GLint /*location*/, GLdouble /*v0*/, GLdouble /*v1*/, GLdouble /*v2*/, GLdouble /*v3*/);
// type proc_glProgramUniform4dv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniform4f          = void(GLuint /*program*/, GLint /*location*/, GLfloat /*v0*/, GLfloat /*v1*/, GLfloat /*v2*/, GLfloat /*v3*/);
// type proc_glProgramUniform4fv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniform4i          = void(GLuint /*program*/, GLint /*location*/, GLint /*v0*/, GLint /*v1*/, GLint /*v2*/, GLint /*v3*/);
// type proc_glProgramUniform4iv         = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLint* /*value*/);
// type proc_glProgramUniform4ui         = void(GLuint /*program*/, GLint /*location*/, GLuint /*v0*/, GLuint /*v1*/, GLuint /*v2*/, GLuint /*v3*/);
// type proc_glProgramUniform4uiv        = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, /*const*/ GLuint* /*value*/);
// type proc_glProgramUniformMatrix2dv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix2fv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix2x3dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix2x3fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix2x4dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix2x4fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix3dv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix3fv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix3x2dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix3x2fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix3x4dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix3x4fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix4dv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix4fv   = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix4x2dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix4x2fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);
// type proc_glProgramUniformMatrix4x3dv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLdouble* /*value*/);
// type proc_glProgramUniformMatrix4x3fv = void(GLuint /*program*/, GLint /*location*/, GLsizei /*count*/, GLboolean /*transpose*/, /*const*/ GLfloat* /*value*/);



char* opengl_const_to_glsl_type_name(GLenum ty) switch (ty) {
    case GL_FLOAT:                                     return "float";
    case GL_FLOAT_VEC2:                                return "vec2";
    case GL_FLOAT_VEC3:                                return "vec3";
    case GL_FLOAT_VEC4:                                return "vec4";
    case GL_DOUBLE:                                    return "double";
    case GL_DOUBLE_VEC2:                               return "dvec2";
    case GL_DOUBLE_VEC3:                               return "dvec3";
    case GL_DOUBLE_VEC4:                               return "dvec4";
    case GL_INT:                                       return "int";
    case GL_INT_VEC2:                                  return "ivec2";
    case GL_INT_VEC3:                                  return "ivec3";
    case GL_INT_VEC4:                                  return "ivec4";
    case GL_UNSIGNED_INT:                              return "unsigned int";
    case GL_UNSIGNED_INT_VEC2:                         return "uvec2";
    case GL_UNSIGNED_INT_VEC3:                         return "uvec3";
    case GL_UNSIGNED_INT_VEC4:                         return "uvec4";
    case GL_BOOL:                                      return "bool";
    case GL_BOOL_VEC2:                                 return "bvec2";
    case GL_BOOL_VEC3:                                 return "bvec3";
    case GL_BOOL_VEC4:                                 return "bvec4";
    case GL_FLOAT_MAT2:                                return "mat2";
    case GL_FLOAT_MAT3:                                return "mat3";
    case GL_FLOAT_MAT4:                                return "mat4";
    case GL_FLOAT_MAT2x3:                              return "mat2x3";
    case GL_FLOAT_MAT2x4:                              return "mat2x4";
    case GL_FLOAT_MAT3x2:                              return "mat3x2";
    case GL_FLOAT_MAT3x4:                              return "mat3x4";
    case GL_FLOAT_MAT4x2:                              return "mat4x2";
    case GL_FLOAT_MAT4x3:                              return "mat4x3";
    case GL_DOUBLE_MAT2:                               return "dmat2";
    case GL_DOUBLE_MAT3:                               return "dmat3";
    case GL_DOUBLE_MAT4:                               return "dmat4";
    case GL_DOUBLE_MAT2x3:                             return "dmat2x3";
    case GL_DOUBLE_MAT2x4:                             return "dmat2x4";
    case GL_DOUBLE_MAT3x2:                             return "dmat3x2";
    case GL_DOUBLE_MAT3x4:                             return "dmat3x4";
    case GL_DOUBLE_MAT4x2:                             return "dmat4x2";
    case GL_DOUBLE_MAT4x3:                             return "dmat4x3";
    case GL_SAMPLER_1D:                                return "sampler1D";
    case GL_SAMPLER_2D:                                return "sampler2D";
    case GL_SAMPLER_3D:                                return "sampler3D";
    case GL_SAMPLER_CUBE:                              return "samplerCube";
    case GL_SAMPLER_1D_SHADOW:                         return "sampler1DShadow";
    case GL_SAMPLER_2D_SHADOW:                         return "sampler2DShadow";
    case GL_SAMPLER_1D_ARRAY:                          return "sampler1DArray";
    case GL_SAMPLER_2D_ARRAY:                          return "sampler2DArray";
    case GL_SAMPLER_1D_ARRAY_SHADOW:                   return "sampler1DArrayShadow";
    case GL_SAMPLER_2D_ARRAY_SHADOW:                   return "sampler2DArrayShadow";
    case GL_SAMPLER_2D_MULTISAMPLE:                    return "sampler2DMS";
    case GL_SAMPLER_2D_MULTISAMPLE_ARRAY:              return "sampler2DMSArray";
    case GL_SAMPLER_CUBE_SHADOW:                       return "samplerCubeShadow";
    case GL_SAMPLER_BUFFER:                            return "samplerBuffer";
    case GL_SAMPLER_2D_RECT:                           return "sampler2DRect";
    case GL_SAMPLER_2D_RECT_SHADOW:                    return "sampler2DRectShadow";
    case GL_INT_SAMPLER_1D:                            return "isampler1D";
    case GL_INT_SAMPLER_2D:                            return "isampler2D";
    case GL_INT_SAMPLER_3D:                            return "isampler3D";
    case GL_INT_SAMPLER_CUBE:                          return "isamplerCube";
    case GL_INT_SAMPLER_1D_ARRAY:                      return "isampler1DArray";
    case GL_INT_SAMPLER_2D_ARRAY:                      return "isampler2DArray";
    case GL_INT_SAMPLER_2D_MULTISAMPLE:                return "isampler2DMS";
    case GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          return "isampler2DMSArray";
    case GL_INT_SAMPLER_BUFFER:                        return "isamplerBuffer";
    case GL_INT_SAMPLER_2D_RECT:                       return "isampler2DRect";
    case GL_UNSIGNED_INT_SAMPLER_1D:                   return "usampler1D";
    case GL_UNSIGNED_INT_SAMPLER_2D:                   return "usampler2D";
    case GL_UNSIGNED_INT_SAMPLER_3D:                   return "usampler3D";
    case GL_UNSIGNED_INT_SAMPLER_CUBE:                 return "usamplerCube";
    case GL_UNSIGNED_INT_SAMPLER_1D_ARRAY:             return "usampler1DArray";
    case GL_UNSIGNED_INT_SAMPLER_2D_ARRAY:             return "usampler2DArray";
    case GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       return "usampler2DMS";
    case GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: return "usampler2DMSArray";
    case GL_UNSIGNED_INT_SAMPLER_BUFFER:               return "usamplerBuffer";
    case GL_UNSIGNED_INT_SAMPLER_2D_RECT:              return "usampler2DRect";

    default: return null;
}